#######################################################
Task 2 code
#######################################################

"1D Advection model for pollutant transport in a river. Task 2 - Allow the user to specify the model domain and resolution"

import numpy as np
import pandas as pd

def create_domain(x_max: float, dx: float, t_max: float, dt: float):
"""
Creates spatial and temporal grids.
"""
if dx <= 0 or dt <= 0:
raise ValueError("dx and dt must be positive")

x = np.arange(0, x_max + dx, dx)
t = np.arange(0, t_max + dt, dt)
return x, t

def initialise_concentration(x, mode="delta", value=250.0, csv_file=None):
"""
Initialises the pollutant concentration.
"""
theta0 = np.zeros_like(x, dtype=float)

if mode == "delta":
theta0[0] = value

elif mode == "csv":
if csv_file is None:
raise ValueError("csv_file must be provided when mode='csv'")
data = pd.read_csv(csv_file)
if not {"x", "concentration"}.issubset(data.columns):
raise ValueError("CSV must contain 'x' and 'concentration' columns")
theta0 = np.interp(x, data["x"], data["concentration"])

else:
raise ValueError("Unknown initialisation mode")

return theta0

def compute_courant_number(U, dt, dx):
"Computes courant number for stability diagnostics."
if np.isscalar(U):
return abs(U) * dt / dx
else:
return np.max(np.abs(U)) * dt / dx

def enforce_stability(U, dt, dx, safety_factor=0.9):
"""
Adjust dt automatically if Courant number exceeds 1.

Returns
dt_stable : float
Adjusted stable timestep
courant : float
courant number after adjustment
"""
courant = compute_courant_number(U, dt, dx)
if courant <= 1.0:
return dt, courant

dt_stable = safety_factor * dx / (abs(U) if np.isscalar(U) else np.max(np.abs(U)))
return dt_stable, safety_factor

def solve_advection(x, t, theta0, U, auto_stabilise=True):
"""
Solve 1D advection equation using upwind finite differences.

If auto_stabilise=True, dt is reduced automatically to satisfy
the courant condition instead of raising an error.
"""
dx = x[1] - x[0]
dt = t[1] - t[0]

if auto_stabilise:
dt_new, courant = enforce_stability(U, dt, dx)
if dt_new != dt:
t = np.arange(t[0], t[-1] + dt_new, dt_new)
dt = dt_new
else:
courant = compute_courant_number(U, dt, dx)
if courant > 1:
raise ValueError(f"Unstable configuration: Courant number = {courant:.2f} > 1")

nx = len(x)
nt = len(t)

theta = np.zeros((nt, nx))
theta[0, :] = theta0

for n in range(0, nt - 1):
for i in range(1, nx):
u_local = U if np.isscalar(U) else U[i]
theta[n + 1, i] = (
theta[n, i]
- u_local * dt / dx * (theta[n, i] - theta[n, i - 1])
)
# The boundary condition at x=0
theta[n + 1, 0] = 0.0

return theta, t



#######################################################
test case 2
#######################################################

import pandas as pd
import numpy as np

def read_and_interpolate_initial_conditions(csv_path, x_grid, x_col='x', theta_col='theta'):
   
    "Read initial_conditions.csv and interpolate the measurements onto the model grid."

  """
    Parameters:
    csv_path : str
        #Path to the CSV file.
    x_grid : array-like
        #The model's spatial grid (e.g., produced using np.linspace).
    x_col : str
        #Name of the column in the CSV that holds x-coordinates.
    theta_col : str
        #Name of the column in the CSV that holds concentration values.

    Gives:
    theta_interp : np.ndarray
    # Interpolated concentration values matching the model grid."
    # Read CSV using pandas
    df = pd.read_csv(csv_path)
    """
    # Extract measurements
    x_measured = df[x_col].values
    theta_measured = df[theta_col].values

    # Sort by x so interpolation works correctly
    sort_idx = np.argsort(x_measured)
    x_measured = x_measured[sort_idx]
    theta_measured = theta_measured[sort_idx]

    # Interpolate onto model grid
    theta_interp = np.interp(
        x_grid,               # target grid for the model
        x_measured,           # measurement positions
        theta_measured,       # measured concentrations
        left=theta_measured[0],   # extrapolate left using nearest value
        right=theta_measured[-1]  # extrapolate right using nearest value
    )

    return theta_interp

#Making the grid
x = np.linspace(0, 20, 101)   # example grid: 0â€“20 m, dx=0.2 m

#Reads & interpolates CSV initial conditions
theta0 = read_and_interpolate_initial_conditions(
    'data/initial_conditions.csv',
    x
)
